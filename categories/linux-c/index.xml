<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux-c on ARAIR</title><link>https://arair.net/categories/linux-c/</link><description>Recent content in linux-c on ARAIR</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 24 Jul 2021 17:22:14 +0800</lastBuildDate><atom:link href="https://arair.net/categories/linux-c/index.xml" rel="self" type="application/rss+xml"/><item><title>C库函数-memset</title><link>https://arair.net/p/language/c/linux/b0463797/</link><pubDate>Sat, 24 Jul 2021 17:22:14 +0800</pubDate><guid>https://arair.net/p/language/c/linux/b0463797/</guid><description>C 库函数 void *memset(void *str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 声明 下面是 memset() 函数的声明。 void *memset(void *str, int c, size_t n) 参数 str &amp;ndash; 指向要填</description></item><item><title>C库函数 memcpy</title><link>https://arair.net/p/language/c/linux/e0c6ff04/</link><pubDate>Sat, 24 Jul 2021 10:38:53 +0800</pubDate><guid>https://arair.net/p/language/c/linux/e0c6ff04/</guid><description>C 库函数 void *memcpy(void *str1, const void *str2, size_t n) 从存储区 str2 复制 n 个字节到存储区 str1。 声明 #include &amp;lt;string.h&amp;gt; void *memcpy(void *str1, const void *str2, size_t n) 参数 str1 &amp;ndash; 指向用于存储复制内容的目标数组，类型强制转换</description></item><item><title>linux-c 格式化输出函数</title><link>https://arair.net/p/language/c/linux/c2fb0965f61f47a4b6412ce62b324548/</link><pubDate>Sat, 10 Jul 2021 17:18:13 +0800</pubDate><guid>https://arair.net/p/language/c/linux/c2fb0965f61f47a4b6412ce62b324548/</guid><description>&lt;h2 id="stdioh">stdio.h&lt;/h2>
&lt;h3 id="snprintf">snprintf&lt;/h3>
&lt;p>C 库函数 **int snprintf(char &lt;em>str, size_t size, const char &lt;em>format, &amp;hellip;)&lt;/em>&lt;/em> 设将可变参数(&amp;hellip;)按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断。&lt;/p></description></item><item><title>linux-c sleep usleep函数</title><link>https://arair.net/p/language/c/linux/1bb3a166/</link><pubDate>Sat, 10 Jul 2021 17:02:50 +0800</pubDate><guid>https://arair.net/p/language/c/linux/1bb3a166/</guid><description>&lt;p>在linux编程中，有时候会用到定时功能，常见的是用sleep(time)函数来睡眠time秒；但是这个函数是可以被中断的，也就是说当进程在睡眠的过程中，如果被中断，那么当中断结束回来再执行该进程的时候，该进程会从sleep函数的下一条语句执行；这样的话就不会睡眠time秒了；&lt;/p></description></item><item><title>linux-c system函数</title><link>https://arair.net/p/language/c/linux/3656b6ee8cb04f7986a25e00ed884a96/</link><pubDate>Sat, 10 Jul 2021 16:56:52 +0800</pubDate><guid>https://arair.net/p/language/c/linux/3656b6ee8cb04f7986a25e00ed884a96/</guid><description>C 库函数 system 把command指定的命令名称或程序名称传给要被命令处理器执行的主机环境，并在命令完成后返回。 #include &amp;lt;stdlib.h&amp;gt; int system(const char *command) 参数 command &amp;ndash; 包含被请求变量名</description></item><item><title>linux c--文件IO</title><link>https://arair.net/p/language/c/linux/b1c11950/</link><pubDate>Wed, 30 Jun 2021 20:06:23 +0800</pubDate><guid>https://arair.net/p/language/c/linux/b1c11950/</guid><description>&lt;p>系统通过文件描述符(file descriptor：一个非负的整型值)将各种IO类型统一起来。这些IO类型包括普通文件，终端，管道，FIFO，设备，套接字等等。有了文件描述符，就可以使用一套统一的IO函数：open/read/write/close等。&lt;/p></description></item><item><title>linux c assert函数</title><link>https://arair.net/p/language/c/linux/51c8743a/</link><pubDate>Thu, 24 Jun 2021 11:37:59 +0800</pubDate><guid>https://arair.net/p/language/c/linux/51c8743a/</guid><description>&lt;p>assert()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句，它的作用是终止程序以免导致严重后果，同时也便于查找错误。&lt;/p></description></item><item><title>linux c syslog函数</title><link>https://arair.net/p/language/c/linux/a74307cb/</link><pubDate>Thu, 03 Jun 2021 21:31:26 +0800</pubDate><guid>https://arair.net/p/language/c/linux/a74307cb/</guid><description>&lt;p>openlog， syslog， closelog是一套系统日志写入接口。&lt;/p></description></item><item><title>linux c string相关函数</title><link>https://arair.net/p/language/c/linux/95495d86/</link><pubDate>Thu, 29 Apr 2021 11:24:36 +0800</pubDate><guid>https://arair.net/p/language/c/linux/95495d86/</guid><description>&lt;p>string 函数&lt;/p></description></item><item><title>inet相关函数</title><link>https://arair.net/p/language/c/linux/8233cb24/</link><pubDate>Fri, 02 Apr 2021 15:47:45 +0800</pubDate><guid>https://arair.net/p/language/c/linux/8233cb24/</guid><description>&lt;p>inet_pton - convert IPv4 and IPv6 addresses from text to binary form&lt;/p></description></item><item><title>linux Get Set Time函数</title><link>https://arair.net/p/language/c/linux/f68c01ba/</link><pubDate>Mon, 22 Mar 2021 14:41:12 +0800</pubDate><guid>https://arair.net/p/language/c/linux/f68c01ba/</guid><description>&lt;p>gettimeofday与settimeofday函数说明&lt;/p></description></item><item><title>linux c--标准IO</title><link>https://arair.net/p/language/c/linux/818d73e4/</link><pubDate>Mon, 08 Mar 2021 14:07:53 +0800</pubDate><guid>https://arair.net/p/language/c/linux/818d73e4/</guid><description>&lt;p>标准I/O是ANSI C建立的一个标准I/O模型，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存。&lt;/p>
&lt;ol>
&lt;li>全缓存：当填满标准I/O缓存后才进行实际的I/O操作。&lt;/li>
&lt;li>行缓存：当输入或输出中遇到新行符时，标准I/O库执行I/O操作。&lt;/li>
&lt;li>不带缓存：stderr就是了。&lt;/li>
&lt;/ol></description></item><item><title>linux进程间通信--信号</title><link>https://arair.net/p/language/c/linux/4a8dc548/</link><pubDate>Mon, 08 Mar 2021 10:41:17 +0800</pubDate><guid>https://arair.net/p/language/c/linux/4a8dc548/</guid><description>&lt;p>概念：&lt;/p>
&lt;ol>
&lt;li>信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式&lt;/li>
&lt;li>信号可以直接进行用户空间进程和内核进程之间的交互，内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。&lt;/li>
&lt;li>如果该进程当前并未处于执行态，则该信号就由内核保存起来，直到该进程恢复执行再传递给它；如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被 取消时才被传递给进程。&lt;/li>
&lt;/ol>
&lt;p>用户进程对信号的响应方式：&lt;/p>
&lt;ol>
&lt;li>忽略信号：对信号不做任何处理，但是有两个信号不能忽略：即SIGKILL及SIGSTOP。&lt;/li>
&lt;li>捕捉信号：定义信号处理函数，当信号发生时，执行相应的处理函数。&lt;/li>
&lt;li>执行缺省操作：Linux对每种信号都规定了默认操作&lt;/li>
&lt;/ol></description></item><item><title>linux c--alarm函数</title><link>https://arair.net/p/language/c/linux/a00bff40/</link><pubDate>Mon, 08 Mar 2021 09:26:10 +0800</pubDate><guid>https://arair.net/p/language/c/linux/a00bff40/</guid><description>&lt;p>设置固定时间发送&lt;code>SIGALRM&lt;/code>信号。&lt;/p></description></item><item><title>linux c动态库</title><link>https://arair.net/p/language/c/linux/9eb21010/</link><pubDate>Sun, 07 Mar 2021 21:14:22 +0800</pubDate><guid>https://arair.net/p/language/c/linux/9eb21010/</guid><description>&lt;p>Linux下动态库文件的文件名形如 libxxx.so，其中so是 Shared Object 的缩写，即可以共享的目标文件。&lt;/p>
&lt;p>在链接动态库生成可执行文件时，并不会把动态库的代码复制到执行文件中，而是在执行文件中记录对动态库的引用。&lt;/p>
&lt;p>程序执行时，再去加载动态库文件。如果动态库已经加载，则不必重复加载，从而能节省内存空间。&lt;/p></description></item><item><title>linux 线程</title><link>https://arair.net/p/language/c/linux/a02f9d22/</link><pubDate>Sat, 06 Mar 2021 11:17:46 +0800</pubDate><guid>https://arair.net/p/language/c/linux/a02f9d22/</guid><description>&lt;p>pthread 相关函数&lt;/p></description></item><item><title>linux进程间通信--共享内存</title><link>https://arair.net/p/language/c/linux/052f29b2/</link><pubDate>Sat, 06 Mar 2021 10:41:30 +0800</pubDate><guid>https://arair.net/p/language/c/linux/052f29b2/</guid><description>&lt;h2 id="共享内存">共享内存&lt;/h2>
&lt;p>共享内存是System V版本的最后一个进程间通信方式。共享内存，顾名思义就是允许两个不相关的进程访问同一个逻辑内存，共享内存是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常为同一段物理内存。进程可以将同一段物理内存连接到他们自己的地址空间中，所有的进程都可以访问共享内存中的地址。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。&lt;/p></description></item><item><title>linux进程间通信--套接字</title><link>https://arair.net/p/language/c/linux/e44ccd55/</link><pubDate>Sun, 28 Feb 2021 10:41:34 +0800</pubDate><guid>https://arair.net/p/language/c/linux/e44ccd55/</guid><description>&lt;p>套接字（Socket）用于协调不同计算机上的进程间通信，也就是基于网络的通信。当然，也可以在本机上使用套接字进行进程间的通信。&lt;/p>
&lt;p>套接字通信的方式非常多，有Unix域套接字、TCP套接字、UDP套接字、链路层套接字等等。&lt;/p></description></item><item><title>linux进程间通信--管道</title><link>https://arair.net/p/language/c/linux/a38a3210/</link><pubDate>Sun, 28 Feb 2021 10:41:04 +0800</pubDate><guid>https://arair.net/p/language/c/linux/a38a3210/</guid><description>&lt;p>管道分为有名管道和无名管道&lt;/p>
&lt;p>无名管道是一种半双工的通信方式,数据只能单向流动,而且只能在具有亲缘关系的进程间使用。进程的亲缘关系一般指的是父子关系。无明管道一般用于两个不同进程之间的通信。当一个进程创建了一个管道,并调用fork创建自己的一个子进程后,父进程关闭读管道端,子进程关闭写管道端,这样提供了两个进程之间数据流动的一种方式。&lt;/p>
&lt;p>有名管道也是一种半双工的通信方式,但是它允许无亲缘关系进程间的通信。&lt;/p></description></item><item><title>利用random与urandom生成随机数</title><link>https://arair.net/p/language/c/linux/cad5c2bd/</link><pubDate>Sun, 07 Feb 2021 20:18:22 +0800</pubDate><guid>https://arair.net/p/language/c/linux/cad5c2bd/</guid><description>&lt;ol>
&lt;li>介绍&lt;br>
&lt;code>/dev/random&lt;/code>和&lt;code>/dev/urandom&lt;/code>是Linux系统中提供的随机伪设备，这两个设备的任务，是提供永不为空的随机字节数据流。很多解密程序与安全应用程序（如SSH Keys,SSL Keys等）需要它们提供的随机数据流。&lt;/li>
&lt;li>区别&lt;br>
这两个设备的差异在于：&lt;code>/dev/random&lt;/code>的random依赖于系统中断，因此在系统的中断数不足时，&lt;code>/dev/random&lt;/code>设备会一直封锁，尝试读取的进程就会进入等待状态，直到系统的中断数充分够用, &lt;code>/dev/random&lt;/code>设备可以保证数据的随机性。&lt;br>
&lt;code>/dev/urandom&lt;/code>不依赖系统的中断，也就不会造成进程忙等待，但是数据的随机性也不高。&lt;/li>
&lt;li>使用方式&lt;br>
字符设备文件的打开方式和其它文件一样，都是使用open函数打开设备，然后从文件描述符中获取数据即可。&lt;/li>
&lt;/ol></description></item><item><title>Linux平台C语言记录</title><link>https://arair.net/p/language/c/6fa4517a/</link><pubDate>Thu, 04 Feb 2021 09:54:58 +0800</pubDate><guid>https://arair.net/p/language/c/6fa4517a/</guid><description>&lt;p>用于记录linux平台下c语言的学习记录&lt;/p></description></item><item><title>getifaddrs函数的用法</title><link>https://arair.net/p/language/c/f394b890/</link><pubDate>Thu, 04 Feb 2021 09:48:20 +0800</pubDate><guid>https://arair.net/p/language/c/f394b890/</guid><description>&lt;p>getifaddrs&lt;/p>
&lt;p>获取linux ip地址方法，可以获取相应接口的ipv4和ipv6地址&lt;/p></description></item></channel></rss>