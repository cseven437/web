<!doctype html><html><title>linux进程间通信--套接字 tcp</title><meta name=description content="linux下tcp函数实现示例
包含ipv4与ipv6
"><meta name=generator content="Hugo 0.88.1">
<meta property="og:title" content="linux进程间通信--套接字 tcp">
<meta property="og:description" content="linux下tcp函数实现示例
包含ipv4与ipv6">
<meta property="og:type" content="article">
<meta property="og:url" content="https://arair.net/p/language/c/linux/df98c918/"><meta property="article:section" content="p">
<meta property="article:published_time" content="2021-02-04T10:00:53+08:00">
<meta property="article:modified_time" content="2021-02-04T10:00:53+08:00">
<meta itemprop=name content="linux进程间通信--套接字 tcp">
<meta itemprop=description content="linux下tcp函数实现示例
包含ipv4与ipv6"><meta itemprop=datePublished content="2021-02-04T10:00:53+08:00">
<meta itemprop=dateModified content="2021-02-04T10:00:53+08:00">
<meta itemprop=wordCount content="3535">
<meta itemprop=keywords content="linux,tcp,c,">
<style type=text/css>.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto;padding:45px}@media(max-width:767px){.markdown-body{padding:15px}}</style>
<script>function setTheme({el:a=document.documentElement,mode:b='auto',light:c='light',dark:d='dark'}){a.dataset.colorMode=b,a.dataset.lightTheme=c,a.dataset.darkTheme=d}let prefersDarkMode=window.matchMedia('(prefers-color-scheme: dark)').matches;prefersDarkMode&&setTheme({mode:'dark'})</script>
<link rel=stylesheet href=/style.css type=text/css><body id=content class=markdown-body>
<body>
<div id=post class=post>
<article>
<header>
<h1 class=post-title>linux进程间通信--套接字 tcp</h1>
<p>
<small>
2021-02-04
</small>
</p>
</header>
<aside>
<nav id=TableOfContents>
<ul>
<li><a href=#双栈单独版本>双栈单独版本</a>
<ul>
<li><a href=#server>server</a></li>
<li><a href=#client>client</a></li>
</ul>
</li>
<li><a href=#ipv4与ipv6优化版本>ipv4与ipv6优化版本</a>
<ul>
<li><a href=#server-1>server</a></li>
<li><a href=#client-1>client</a></li>
</ul>
</li>
</ul>
</nav>
</aside>
<p>linux下tcp函数实现示例</p>
<p>包含ipv4与ipv6</p>
<h2 id=双栈单独版本>双栈单独版本</h2>
<h3 id=server>server</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;netinet/in.h&gt; //互联网地址族</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;netdb.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;time.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;ctype.h&gt; //toupper （小写转化为大写）</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=n>port</span> <span class=o>=</span> <span class=mi>8000</span><span class=p>;</span>

<span class=cm>/*服务端*/</span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>

<span class=cp>#ifdef TCP_IPV6
</span><span class=cp></span>    <span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=n>sin</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=n>pin</span><span class=p>;</span>
<span class=cp>#else
</span><span class=cp></span>    <span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=n>sin</span><span class=p>;</span> <span class=c1>//struct sockaddr和struct sockaddr_in这两个结构体用来处理网络通信的地址。
</span><span class=c1></span>    <span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=n>pin</span><span class=p>;</span>
<span class=cp>#endif
</span><span class=cp></span>    <span class=kt>int</span> <span class=n>sock_descriptor</span><span class=p>;</span> <span class=c1>//  套接口描述字
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>temp_sock_descriptor</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>address_size</span><span class=p>;</span>
    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>16384</span><span class=p>];</span> <span class=c1>// 缓冲区大小
</span><span class=c1></span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>len</span><span class=p>;</span>

    <span class=cm>/*
</span><span class=cm>     *int socket(int domain, int type, int protocol);
</span><span class=cm>     * PF_INET, AF_INET： Ipv4网络协议
</span><span class=cm>     * PF_INET6, AF_INET6： Ipv6网络协议。
</span><span class=cm>     * type参数的作用是设置通信的协议类型，可能的取值如下所示：
</span><span class=cm>　　      SOCK_STREAM： 提供面向连接的稳定数据传输，即TCP协议。
</span><span class=cm>　　      OOB： 在所有数据传送前必须使用connect()来建立连接状态。
</span><span class=cm>　      　SOCK_DGRAM： 使用不连续不可靠的数据包连接。
</span><span class=cm>　　      SOCK_SEQPACKET： 提供连续可靠的数据包连接。
</span><span class=cm>　      　SOCK_RAW： 提供原始网络协议存取。
</span><span class=cm>　      　SOCK_RDM： 提供可靠的数据包连接。
</span><span class=cm>　　      SOCK_PACKET： 与网络驱动程序直接通信。
</span><span class=cm>     */</span>
    <span class=c1>//socket函数，向系统申请一个通信端口
</span><span class=c1></span><span class=cp>#ifdef TCP_IPV6
</span><span class=cp></span>    <span class=n>sock_descriptor</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>AF_INET6</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> 
<span class=cp>#else
</span><span class=cp></span>    <span class=n>sock_descriptor</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>//IPV4 TCP协议
</span><span class=c1></span><span class=cp>#endif
</span><span class=cp></span>    <span class=k>if</span> <span class=p>(</span><span class=n>sock_descriptor</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>                         <span class=c1>//申请失败
</span><span class=c1></span>    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;call to socket&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=n>bzero</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sin</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>sin</span><span class=p>));</span>         <span class=c1>// 初始化 然后是设置套接字
</span><span class=c1></span><span class=cp>#ifdef TCP_IPV6
</span><span class=cp></span>    <span class=n>sin</span><span class=p>.</span><span class=n>sin6_family</span> <span class=o>=</span> <span class=n>AF_INET6</span><span class=p>;</span>
    <span class=n>sin</span><span class=p>.</span><span class=n>sin6_addr</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>in6_addr</span><span class=p>)</span><span class=n>IN6ADDR_ANY_INIT</span><span class=p>;</span>
    <span class=n>sin</span><span class=p>.</span><span class=n>sin6_port</span> <span class=o>=</span> <span class=n>htons</span><span class=p>(</span><span class=n>port</span><span class=p>);</span>
<span class=cp>#else
</span><span class=cp></span>    <span class=n>sin</span><span class=p>.</span><span class=n>sin_family</span> <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>         <span class=c1>//协议族，在socket编程中只能是AF_INET(TCP/IP协议族)
</span><span class=c1></span>    <span class=n>sin</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span> <span class=o>=</span> <span class=n>INADDR_ANY</span><span class=p>;</span> <span class=c1>//sin_addr存储IP地址,使用in_addr这个数据结构
</span><span class=c1></span>                                      <span class=c1>//s_addr按照网络字节顺序存储IP地址
</span><span class=c1></span>                                      <span class=c1>//in_addr32位的IPv4地址
</span><span class=c1></span>    <span class=n>sin</span><span class=p>.</span><span class=n>sin_port</span> <span class=o>=</span> <span class=n>htons</span><span class=p>(</span><span class=n>port</span><span class=p>);</span>       <span class=c1>//存储端口号
</span><span class=c1></span><span class=cp>#endif
</span><span class=cp></span>    <span class=c1>//将套接字（sin） 跟端口（sock_descriptor）链接
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>bind</span><span class=p>(</span><span class=n>sock_descriptor</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>sin</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>sin</span><span class=p>))</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;call to bind&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=cm>/*int PASCAL FAR listen( SOCKET s, int backlog);
</span><span class=cm>　　     S：用于标识一个已捆绑未连接套接口的描述字。
</span><span class=cm>　　     backlog：等待连接队列的最大长度。
</span><span class=cm>     * listen()仅适用于支持连接的套接口，如SOCK_STREAM类型的。
</span><span class=cm>     */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>listen</span><span class=p>(</span><span class=n>sock_descriptor</span><span class=p>,</span> <span class=mi>20</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=c1>//在端口sock_descriptor监听
</span><span class=c1></span>    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;call to listen&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;accepting connections </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>

    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>{</span> <span class=c1>//用来监听的端口sock_descriptor
</span><span class=c1></span>        <span class=n>temp_sock_descriptor</span> <span class=o>=</span> <span class=n>accept</span><span class=p>(</span><span class=n>sock_descriptor</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>pin</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>address_size</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>temp_sock_descriptor</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;call to accept&#34;</span><span class=p>);</span>
            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=cm>/*int PASCAL FAR recv( SOCKET s, char FAR* buf, int len, int flags);
</span><span class=cm>　　        s：一个标识已连接套接口的描述字。
</span><span class=cm>　　        buf：用于接收数据的缓冲区。
</span><span class=cm>　　        len：缓冲区长度。
</span><span class=cm>　　        flags：指定调用方式。
</span><span class=cm>         */</span>

        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;wait to recv message</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>

        <span class=k>struct</span> <span class=n>timeval</span> <span class=n>tv</span><span class=p>;</span>

        <span class=c1>// Set up the struct timeval for the timeout.
</span><span class=c1></span>        <span class=n>tv</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>=</span> <span class=mi>30</span><span class=p>;</span>
        <span class=n>tv</span><span class=p>.</span><span class=n>tv_usec</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        
        <span class=c1>// 添加socket延时
</span><span class=c1></span>        <span class=c1>// setsockopt(temp_sock_descriptor, SOL_SOCKET, SO_RCVTIMEO, (char *)&amp;tv, sizeof(struct timeval));
</span><span class=c1></span>
        <span class=k>if</span> <span class=p>(</span><span class=n>recv</span><span class=p>(</span><span class=n>temp_sock_descriptor</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>16384</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;call to recv&#34;</span><span class=p>);</span>
            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;received from client:%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>

        <span class=n>len</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span>
        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>len</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>toupper</span><span class=p>(</span><span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span> <span class=c1>//将小写字母转化为大写字母
</span><span class=c1></span>        <span class=p>}</span>
        <span class=cm>/*int PASCAL FAR send( SOCKET s, const char FAR* buf, int len, int flags);
</span><span class=cm>　　        s：一个用于标识已连接套接口的描述字。
</span><span class=cm>　　        buf：包含待发送数据的缓冲区。
</span><span class=cm>　　        len：缓冲区中数据的长度。
</span><span class=cm>　　        flags：调用执行方式。*/</span>

        <span class=cm>/*send()   基于链接的发送 TCP
</span><span class=cm>         *sendto() 基于无链接到   UDP
</span><span class=cm>         */</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>send</span><span class=p>(</span><span class=n>temp_sock_descriptor</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;call to send&#34;</span><span class=p>);</span>
            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=n>close</span><span class=p>(</span><span class=n>temp_sock_descriptor</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=p>(</span><span class=n>EXIT_SUCCESS</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><h3 id=client>client</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;sys/select.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;netinet/in.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;netdb.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cm>/*客户端*/</span>
<span class=cp>#ifdef TCP_IPV6
</span><span class=cp></span><span class=kt>char</span> <span class=o>*</span><span class=n>host_name</span> <span class=o>=</span> <span class=s>&#34;::1&#34;</span><span class=p>;</span>
<span class=cp>#else
</span><span class=cp></span><span class=kt>char</span> <span class=o>*</span><span class=n>host_name</span> <span class=o>=</span> <span class=s>&#34;127.0.0.1&#34;</span><span class=p>;</span> <span class=c1>//需要搜寻服务端IP地址
</span><span class=c1></span><span class=cp>#endif
</span><span class=cp></span><span class=kt>int</span> <span class=n>port</span> <span class=o>=</span> <span class=mi>8000</span><span class=p>;</span>

<span class=cm>/*argc: 整数,用来统计你运行程序时送给main函数的命令行参数的个数
</span><span class=cm> * argv: 字符串数组，用来存放指向你的字符串参数的指针数组，每一个元素指向一个参数
</span><span class=cm>　　argv[0] 指向程序运行的全路径名
</span><span class=cm>　　argv[1] 指向在DOS命令行中执行程序名后的第一个字符串
</span><span class=cm>　　argv[2] 指向执行程序名后的第二个字符串
</span><span class=cm>   */</span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>8192</span><span class=p>];</span>
    <span class=kt>char</span> <span class=n>message</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span>
    <span class=kt>int</span> <span class=n>socket_descriptor</span><span class=p>;</span>
<span class=cp>#ifdef TCP_IPV6
</span><span class=cp></span>    <span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=n>pin</span><span class=p>;</span>
<span class=cp>#else
</span><span class=cp></span>    <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>pin</span><span class=p>;</span> <span class=c1>//处理网络通信的地址
</span><span class=c1></span><span class=cp>#endif
</span><span class=cp></span>    <span class=cm>/*
</span><span class=cm>     * hostent记录主机的信息，包括主机名、别名、地址类型、地址长度和地址列表
</span><span class=cm>     * struct hostent {
</span><span class=cm>　　       char *h_name;地址的正式名称
</span><span class=cm>　　       char **h_aliases;空字节-地址的预备名称的指针
</span><span class=cm>　　       int h_addrtype;地址类型; 通常是AF_INET。
</span><span class=cm>　       　int h_length;地址的比特长度。
</span><span class=cm>　       　char **h_addr_list;零字节-主机网络地址指针。网络字节顺序。
</span><span class=cm>　　    };
</span><span class=cm>　　   #define h_addr h_addr_list[0] //h_addr_list中的第一地址
</span><span class=cm>     */</span>
    <span class=k>struct</span> <span class=n>hostent</span> <span class=o>*</span><span class=n>server_host_name</span><span class=p>;</span>

    <span class=kt>char</span> <span class=o>*</span><span class=n>str</span> <span class=o>=</span> <span class=s>&#34;A default test string&#34;</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>)</span> <span class=c1>//运行程序时送给main函数到命令行参数个数
</span><span class=c1></span>    <span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Usage:test </span><span class=se>\&#34;</span><span class=s>Any test string</span><span class=se>\&#34;\n</span><span class=s>&#34;</span><span class=p>);</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;we will send a default test string. </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>else</span>
    <span class=p>{</span>
        <span class=n>str</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
    <span class=p>}</span>
    <span class=cm>/*
</span><span class=cm>     * gethostbyname()返回对应于给定主机名的包含主机名字和地址信息的
</span><span class=cm>     * hostent结构指针。结构的声明与gethostaddr()中一致。*/</span>
    <span class=k>if</span> <span class=p>((</span><span class=n>server_host_name</span> <span class=o>=</span> <span class=n>gethostbyname</span><span class=p>(</span><span class=n>host_name</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;Error resolving local host </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=n>bzero</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pin</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>pin</span><span class=p>));</span>
<span class=cp>#ifdef TCP_IPV6
</span><span class=cp></span>    <span class=n>pin</span><span class=p>.</span><span class=n>sin6_family</span> <span class=o>=</span> <span class=n>AF_INET6</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>inet_pton</span><span class=p>(</span><span class=n>AF_INET6</span><span class=p>,</span> <span class=n>host_name</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pin</span><span class=p>.</span><span class=n>sin6_addr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;pton&#34;</span><span class=p>);</span>
        <span class=k>return</span> <span class=mi>2</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>pin</span><span class=p>.</span><span class=n>sin6_port</span> <span class=o>=</span> <span class=n>htons</span><span class=p>(</span><span class=n>port</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>((</span><span class=n>socket_descriptor</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>AF_INET6</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;Error opening socket </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>
<span class=cp>#else
</span><span class=cp></span>    <span class=n>pin</span><span class=p>.</span><span class=n>sin_family</span> <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>
    <span class=c1>//htonl()将主机的无符号长整形数转换成网络字节顺序
</span><span class=c1></span>    <span class=n>pin</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span> <span class=o>=</span> <span class=n>htonl</span><span class=p>(</span><span class=n>INADDR_ANY</span><span class=p>);</span>                                      <span class=c1>//s_addr按照网络字节顺序存储IP地址
</span><span class=c1></span>                                                                                  <span class=c1>//in_addr 32位的IPv4地址  h_addr_list中的第一地址
</span><span class=c1></span>    <span class=n>pin</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span> <span class=o>=</span> <span class=p>((</span><span class=k>struct</span> <span class=n>in_addr</span> <span class=o>*</span><span class=p>)(</span><span class=n>server_host_name</span><span class=o>-&gt;</span><span class=n>h_addr</span><span class=p>))</span><span class=o>-&gt;</span><span class=n>s_addr</span><span class=p>;</span> <span class=c1>// 跟书上不一样 必须是h_addr
</span><span class=c1></span>
    <span class=n>pin</span><span class=p>.</span><span class=n>sin_port</span> <span class=o>=</span> <span class=n>htons</span><span class=p>(</span><span class=n>port</span><span class=p>);</span>
    <span class=cm>/*申请一个通信端口*/</span>
    <span class=k>if</span> <span class=p>((</span><span class=n>socket_descriptor</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;Error opening socket </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>
<span class=cp>#endif
</span><span class=cp></span>    <span class=c1>//pin 定义跟服务端连接的 IP 端口
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>connect</span><span class=p>(</span><span class=n>socket_descriptor</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>pin</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>pin</span><span class=p>))</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;Error connecting to socket </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=c1>////
</span><span class=c1></span>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Sending message %s to server </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>);</span>
    <span class=kt>int</span> <span class=n>num1</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>while</span><span class=p>(</span><span class=n>num1</span><span class=o>++</span> <span class=o>&lt;</span> <span class=mi>60</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;num1:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>num1</span><span class=p>);</span>
        <span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>send</span><span class=p>(</span><span class=n>socket_descriptor</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=n>strlen</span><span class=p>(</span><span class=n>str</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;Error in send</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;..sent message.. wait for response...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>recv</span><span class=p>(</span><span class=n>socket_descriptor</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>8192</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;Error in receiving response from server </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s> Response from server:</span><span class=se>\n\n</span><span class=s>%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>

    <span class=n>close</span><span class=p>(</span><span class=n>socket_descriptor</span><span class=p>);</span>

    <span class=k>return</span> <span class=p>(</span><span class=n>EXIT_SUCCESS</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><h2 id=ipv4与ipv6优化版本>ipv4与ipv6优化版本</h2>
<p>根据argv[1]输入的地址是ipv4 还是ipv6自行判断使用哪一个</p>
<h3 id=server-1>server</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;netinet/in.h&gt; //互联网地址族</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;netdb.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;time.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;ctype.h&gt; //toupper （小写转化为大写）</span><span class=cp>
</span><span class=cp></span>
<span class=c1>// int port = 8000;
</span><span class=c1>// char *server = &#34;localhost&#34;;
</span><span class=c1></span><span class=kt>char</span> <span class=o>*</span><span class=n>server</span> <span class=o>=</span> <span class=s>&#34;127.0.0.1&#34;</span><span class=p>;</span>


<span class=kt>void</span> <span class=nf>PrintSocketAddress</span><span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>address</span><span class=p>,</span> <span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Test for address and stream
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>address</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=n>stream</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
        <span class=k>return</span><span class=p>;</span>

    <span class=kt>void</span> <span class=o>*</span><span class=n>numericAddress</span><span class=p>;</span> <span class=c1>// Pointer to binary address
</span><span class=c1></span>    <span class=c1>// Buffer to contain result (IPv6 sufficient to hold IPv4)
</span><span class=c1></span>    <span class=kt>char</span> <span class=n>addrBuffer</span><span class=p>[</span><span class=n>INET6_ADDRSTRLEN</span><span class=p>];</span>
    <span class=n>in_port_t</span> <span class=n>port</span><span class=p>;</span> <span class=c1>// Port to print
</span><span class=c1></span>    <span class=c1>// Set pointer to address based on address family
</span><span class=c1></span>    <span class=k>switch</span> <span class=p>(</span><span class=n>address</span><span class=o>-&gt;</span><span class=n>sa_family</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nl>AF_INET</span><span class=p>:</span>
            <span class=n>numericAddress</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>((</span><span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=o>*</span><span class=p>)</span> <span class=n>address</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>sin_addr</span><span class=p>;</span>
            <span class=n>port</span> <span class=o>=</span> <span class=n>ntohs</span><span class=p>(((</span><span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=o>*</span><span class=p>)</span> <span class=n>address</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>sin_port</span><span class=p>);</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=k>case</span> <span class=nl>AF_INET6</span><span class=p>:</span>
            <span class=n>numericAddress</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>((</span><span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=o>*</span><span class=p>)</span> <span class=n>address</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>sin6_addr</span><span class=p>;</span>
            <span class=n>port</span> <span class=o>=</span> <span class=n>ntohs</span><span class=p>(((</span><span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=o>*</span><span class=p>)</span> <span class=n>address</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>sin6_port</span><span class=p>);</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=k>default</span><span class=o>:</span>
            <span class=n>fputs</span><span class=p>(</span><span class=s>&#34;[unknown type]&#34;</span><span class=p>,</span> <span class=n>stream</span><span class=p>);</span>    <span class=c1>// Unhandled type
</span><span class=c1></span>            <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// Convert binary to printable address
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>inet_ntop</span><span class=p>(</span><span class=n>address</span><span class=o>-&gt;</span><span class=n>sa_family</span><span class=p>,</span> <span class=n>numericAddress</span><span class=p>,</span> <span class=n>addrBuffer</span><span class=p>,</span>
                <span class=k>sizeof</span><span class=p>(</span><span class=n>addrBuffer</span><span class=p>))</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
        <span class=n>fputs</span><span class=p>(</span><span class=s>&#34;[invalid address]&#34;</span><span class=p>,</span> <span class=n>stream</span><span class=p>);</span> <span class=c1>// Unable to convert
</span><span class=c1></span>    <span class=k>else</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stream</span><span class=p>,</span> <span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>addrBuffer</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>port</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>                <span class=c1>// Zero not valid in any socket addr
</span><span class=c1></span>            <span class=n>fprintf</span><span class=p>(</span><span class=n>stream</span><span class=p>,</span> <span class=s>&#34;-%u&#34;</span><span class=p>,</span> <span class=n>port</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>create_socket</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>servername</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>port</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>sockfd</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>address_size</span><span class=p>;</span>

    <span class=k>struct</span> <span class=n>addrinfo</span> <span class=n>hints</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>addrinfo</span> <span class=o>*</span><span class=n>result</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>len</span><span class=p>;</span>

    <span class=n>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>hints</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>hints</span><span class=p>));</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_family</span> <span class=o>=</span> <span class=n>AF_UNSPEC</span><span class=p>;</span>    <span class=cm>/* Allow IPv4 or IPv6 */</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_socktype</span> <span class=o>=</span> <span class=n>SOCK_STREAM</span><span class=p>;</span> <span class=cm>/* Datagram socket */</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_flags</span> <span class=o>=</span> <span class=n>AI_PASSIVE</span><span class=p>;</span>    <span class=cm>/* For wildcard IP address */</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_protocol</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>          <span class=cm>/* Any protocol */</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_canonname</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_addr</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=n>getaddrinfo</span><span class=p>(</span><span class=n>servername</span><span class=p>,</span> <span class=n>port</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>hints</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>result</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;getaddrinfo: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>gai_strerror</span><span class=p>(</span><span class=n>s</span><span class=p>));</span>
        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>//socket函数，向系统申请一个通信端口
</span><span class=c1></span>    <span class=n>sockfd</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>result</span><span class=o>-&gt;</span><span class=n>ai_family</span><span class=p>,</span> <span class=n>result</span><span class=o>-&gt;</span><span class=n>ai_socktype</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>//IPV4 TCP协议
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>sockfd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>                         <span class=c1>//申请失败
</span><span class=c1></span>    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;call to socket&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>//将套接字（sin） 跟端口（sockfd）链接
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>bind</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span> <span class=n>result</span><span class=o>-&gt;</span><span class=n>ai_addr</span><span class=p>,</span> <span class=n>result</span><span class=o>-&gt;</span><span class=n>ai_addrlen</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;call to bind&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>struct</span> <span class=n>sockaddr_storage</span> <span class=n>local_addr</span><span class=p>;</span>
    <span class=n>socklen_t</span> <span class=n>addr_size</span><span class=o>=</span><span class=k>sizeof</span><span class=p>(</span><span class=n>local_addr</span><span class=p>);</span>
    <span class=k>if</span><span class=p>(</span><span class=n>getsockname</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>local_addr</span><span class=p>,</span><span class=o>&amp;</span><span class=n>addr_size</span><span class=p>)</span><span class=o>&lt;</span><span class=mi>0</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=c1>// DieWithSystemMessage(&#34;getsockname() failed!&#34;);
</span><span class=c1></span>    <span class=p>}</span>
    <span class=n>fputs</span><span class=p>(</span><span class=s>&#34;Binding to &#34;</span><span class=p>,</span><span class=n>stdout</span><span class=p>);</span>
    <span class=n>PrintSocketAddress</span><span class=p>((</span><span class=k>struct</span> <span class=n>sockaddr</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>local_addr</span><span class=p>,</span><span class=n>stdout</span><span class=p>);</span>
    <span class=n>freeaddrinfo</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>

    <span class=cm>/*int PASCAL FAR listen( SOCKET s, int backlog);
</span><span class=cm>　　     S：用于标识一个已捆绑未连接套接口的描述字。
</span><span class=cm>　　     backlog：等待连接队列的最大长度。
</span><span class=cm>     * listen()仅适用于支持连接的套接口，如SOCK_STREAM类型的。
</span><span class=cm>     */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>listen</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span> <span class=mi>20</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=c1>//在端口sockfd监听
</span><span class=c1></span>    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;call to listen&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;accepting connections </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>sockfd</span><span class=p>;</span>
<span class=p>}</span>

<span class=cm>/*服务端*/</span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>

    <span class=kt>int</span> <span class=n>sock_descriptor</span> <span class=o>=</span> <span class=n>create_socket</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=s>&#34;8000&#34;</span><span class=p>);</span>
    <span class=kt>int</span> <span class=n>temp_sock_descriptor</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>address_size</span><span class=p>;</span>
    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>16384</span><span class=p>];</span> <span class=c1>// 缓冲区大小
</span><span class=c1></span>    <span class=k>struct</span> <span class=n>sockaddr_storage</span> <span class=n>pin</span><span class=p>;</span>
    <span class=n>address_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>pin</span><span class=p>);</span>

    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>len</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>{</span> <span class=c1>//用来监听的端口sock_descriptor
</span><span class=c1></span>        <span class=n>temp_sock_descriptor</span> <span class=o>=</span> <span class=n>accept</span><span class=p>(</span><span class=n>sock_descriptor</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>pin</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>address_size</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>temp_sock_descriptor</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;call to accept&#34;</span><span class=p>);</span>
            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=cm>/*int PASCAL FAR recv( SOCKET s, char FAR* buf, int len, int flags);
</span><span class=cm>　　        s：一个标识已连接套接口的描述字。
</span><span class=cm>　　        buf：用于接收数据的缓冲区。
</span><span class=cm>　　        len：缓冲区长度。
</span><span class=cm>　　        flags：指定调用方式。
</span><span class=cm>         */</span>

        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;wait to recv message</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>

        <span class=k>struct</span> <span class=n>timeval</span> <span class=n>tv</span><span class=p>;</span>

        <span class=c1>// Set up the struct timeval for the timeout.
</span><span class=c1></span>        <span class=n>tv</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>=</span> <span class=mi>30</span><span class=p>;</span>
        <span class=n>tv</span><span class=p>.</span><span class=n>tv_usec</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        
        <span class=c1>// 添加socket延时
</span><span class=c1></span>        <span class=c1>// setsockopt(temp_sock_descriptor, SOL_SOCKET, SO_RCVTIMEO, (char *)&amp;tv, sizeof(struct timeval));
</span><span class=c1></span>
        <span class=k>if</span> <span class=p>(</span><span class=n>recv</span><span class=p>(</span><span class=n>temp_sock_descriptor</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>16384</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;call to recv&#34;</span><span class=p>);</span>
            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;received from client:%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>

        <span class=n>len</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span>
        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>len</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>toupper</span><span class=p>(</span><span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span> <span class=c1>//将小写字母转化为大写字母
</span><span class=c1></span>        <span class=p>}</span>
        <span class=cm>/*int PASCAL FAR send( SOCKET s, const char FAR* buf, int len, int flags);
</span><span class=cm>　　        s：一个用于标识已连接套接口的描述字。
</span><span class=cm>　　        buf：包含待发送数据的缓冲区。
</span><span class=cm>　　        len：缓冲区中数据的长度。
</span><span class=cm>　　        flags：调用执行方式。*/</span>

        <span class=cm>/*send()   基于链接的发送 TCP
</span><span class=cm>         *sendto() 基于无链接到   UDP
</span><span class=cm>         */</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>send</span><span class=p>(</span><span class=n>temp_sock_descriptor</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;call to send&#34;</span><span class=p>);</span>
            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=n>close</span><span class=p>(</span><span class=n>temp_sock_descriptor</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=p>(</span><span class=n>EXIT_SUCCESS</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><h3 id=client-1>client</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;sys/select.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;netinet/in.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;netdb.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cm>/*客户端*/</span>
<span class=c1>// char *host_name = &#34;fe80::20c:29ff:fe09:2d36&#34;; //需要搜寻服务端IP地址
</span><span class=c1>// char *host_name = &#34;::1&#34;; //需要搜寻服务端IP地址
</span><span class=c1></span><span class=kt>int</span> <span class=n>port</span> <span class=o>=</span> <span class=mi>8000</span><span class=p>;</span>


<span class=kt>int</span> <span class=nf>create_sock</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>servername</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>port</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>sockfd</span><span class=p>;</span>

    <span class=k>struct</span> <span class=n>addrinfo</span> <span class=n>hints</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>addrinfo</span> <span class=o>*</span><span class=n>result</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>len</span><span class=p>;</span>

    <span class=n>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>hints</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>hints</span><span class=p>));</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_family</span> <span class=o>=</span> <span class=n>AF_UNSPEC</span><span class=p>;</span>    <span class=cm>/* Allow IPv4 or IPv6 */</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_socktype</span> <span class=o>=</span> <span class=n>SOCK_STREAM</span><span class=p>;</span> <span class=cm>/* Datagram socket */</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_flags</span> <span class=o>=</span> <span class=n>AI_PASSIVE</span><span class=p>;</span>    <span class=cm>/* For wildcard IP address */</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_protocol</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>          <span class=cm>/* Any protocol */</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_canonname</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_addr</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=n>hints</span><span class=p>.</span><span class=n>ai_next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=n>getaddrinfo</span><span class=p>(</span><span class=n>servername</span><span class=p>,</span> <span class=n>port</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>hints</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>result</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;getaddrinfo: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>gai_strerror</span><span class=p>(</span><span class=n>s</span><span class=p>));</span>
        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>//socket函数，向系统申请一个通信端口
</span><span class=c1></span>    <span class=n>sockfd</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>result</span><span class=o>-&gt;</span><span class=n>ai_family</span><span class=p>,</span> <span class=n>result</span><span class=o>-&gt;</span><span class=n>ai_socktype</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>//IPV4 TCP协议
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>sockfd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>                         <span class=c1>//申请失败
</span><span class=c1></span>    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;call to socket&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>//pin 定义跟服务端连接的 IP 端口
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>connect</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span> <span class=n>result</span><span class=o>-&gt;</span><span class=n>ai_addr</span><span class=p>,</span> <span class=n>result</span><span class=o>-&gt;</span><span class=n>ai_addrlen</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;Error connecting to socket </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=c1>////
</span><span class=c1></span>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=n>freeaddrinfo</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>sockfd</span><span class=p>;</span>
<span class=p>}</span>

<span class=cm>/*argc: 整数,用来统计你运行程序时送给main函数的命令行参数的个数
</span><span class=cm> * argv: 字符串数组，用来存放指向你的字符串参数的指针数组，每一个元素指向一个参数
</span><span class=cm>　　argv[0] 指向程序运行的全路径名
</span><span class=cm>　　argv[1] 指向在DOS命令行中执行程序名后的第一个字符串
</span><span class=cm>　　argv[2] 指向执行程序名后的第二个字符串
</span><span class=cm>   */</span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>8192</span><span class=p>];</span>
    <span class=kt>char</span> <span class=n>message</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span>
    <span class=kt>int</span> <span class=n>socket_descriptor</span><span class=p>;</span>
    <span class=cm>/*
</span><span class=cm>     * hostent记录主机的信息，包括主机名、别名、地址类型、地址长度和地址列表
</span><span class=cm>     * struct hostent {
</span><span class=cm>　　       char *h_name;地址的正式名称
</span><span class=cm>　　       char **h_aliases;空字节-地址的预备名称的指针
</span><span class=cm>　　       int h_addrtype;地址类型; 通常是AF_INET。
</span><span class=cm>　       　int h_length;地址的比特长度。
</span><span class=cm>　       　char **h_addr_list;零字节-主机网络地址指针。网络字节顺序。
</span><span class=cm>　　    };
</span><span class=cm>　　   #define h_addr h_addr_list[0] //h_addr_list中的第一地址
</span><span class=cm>     */</span>

    <span class=kt>char</span> <span class=o>*</span><span class=n>str</span> <span class=o>=</span> <span class=s>&#34;A default test string&#34;</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>)</span> <span class=c1>//运行程序时送给main函数到命令行参数个数
</span><span class=c1></span>    <span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Usage:test </span><span class=se>\&#34;</span><span class=s>Any test string</span><span class=se>\&#34;\n</span><span class=s>&#34;</span><span class=p>);</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;we will send a default test string. </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>else</span>
    <span class=p>{</span>
        <span class=n>str</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
    <span class=p>}</span>

    <span class=n>socket_descriptor</span> <span class=o>=</span> <span class=n>create_sock</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=s>&#34;8000&#34;</span><span class=p>);</span>

    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Sending message %s to server </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>);</span>
    <span class=kt>int</span> <span class=n>num1</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>while</span><span class=p>(</span><span class=n>num1</span><span class=o>++</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;num1:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>num1</span><span class=p>);</span>
        <span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>send</span><span class=p>(</span><span class=n>socket_descriptor</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=n>strlen</span><span class=p>(</span><span class=n>str</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;Error in send</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;..sent message.. wait for response...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>recv</span><span class=p>(</span><span class=n>socket_descriptor</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>8192</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;Error in receiving response from server </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s> Response from server:</span><span class=se>\n\n</span><span class=s>%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>

    <span class=n>close</span><span class=p>(</span><span class=n>socket_descriptor</span><span class=p>);</span>

    <span class=k>return</span> <span class=p>(</span><span class=n>EXIT_SUCCESS</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div>
</article>
</div>
</body>
<div>
<small> words: 3535 tags:</small>
<small><code><a href=https://arair.net/tags/linux>linux</a></code></small>
<small><code><a href=https://arair.net/tags/tcp>tcp</a></code></small>
<small><code><a href=https://arair.net/tags/c>c</a></code></small>
</div>
</html>
</body>
<script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?bd28dafb59c7621d0ab721cefd01691b",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script>
<script id=LA_COLLECT src=//sdk.51.la/js-sdk-pro.min.js></script>
<script>LA.init({id:"JMTlKgP6j8mqnJSa",ck:"JMTlKgP6j8mqnJSa"})</script>
<link rel=stylesheet href=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.2.0/build/styles/default.min.css>
<script src=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.2.0/build/highlight.min.js></script>
<script>hljs.highlightAll()</script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>window.onload=function(){mermaid.initialize({theme:"default"}),mermaid.init(void 0,".language-mermaid")}</script></html>