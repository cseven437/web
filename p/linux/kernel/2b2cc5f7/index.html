<!doctype html><html><title>网络子系统初始化</title><meta name=description content="网络设备初始化 内核初始化代码(init/main.c &amp;ndash;&amp;gt; asmlinkage __visible void __init start_kernel(void))
 ps：这里只介绍网络子系统的初始化流程。
 系统启动时会执行start_kernel对内核的各个子系统进行初始化。start_kernel会进行必要的初始化任务，比如init_IRQ和softirq_init进行硬中断和软中断初始化,在rest_init中会调用内核线程函数创建一个线程执行kernel_init继续进行其它初始化，start_kernel函数将会继续执行下去并退出。在kernel_init函数中的执行关系kernel_init_freeable()&amp;ndash;&amp;gt;do_basic_setup()&amp;ndash;&amp;gt;do_initcalls()，在do_initcalls函数中，会对调用各个子系统的初始化函数，类似subsys_initcall(net_dev_init)函数。其中net_dev_initnet/core/dev.c为网络设备的初始化函数
内核子系统和编译到内核的驱动都是通过do_initcalls进行初始化的
"><meta name=generator content="Hugo 0.88.1">
<meta property="og:title" content="网络子系统初始化">
<meta property="og:description" content="网络设备初始化
内核初始化代码(init/main.c &ndash;> asmlinkage __visible void __init start_kernel(void))

ps：这里只介绍网络子系统的初始化流程。

系统启动时会执行start_kernel对内核的各个子系统进行初始化。start_kernel会进行必要的初始化任务，比如init_IRQ和softirq_init进行硬中断和软中断初始化,在rest_init中会调用内核线程函数创建一个线程执行kernel_init继续进行其它初始化，start_kernel函数将会继续执行下去并退出。在kernel_init函数中的执行关系kernel_init_freeable()&ndash;>do_basic_setup()&ndash;>do_initcalls()，在do_initcalls函数中，会对调用各个子系统的初始化函数，类似subsys_initcall(net_dev_init)函数。其中net_dev_initnet/core/dev.c为网络设备的初始化函数
内核子系统和编译到内核的驱动都是通过do_initcalls进行初始化的">
<meta property="og:type" content="article">
<meta property="og:url" content="https://arair.net/p/linux/kernel/2b2cc5f7/"><meta property="article:section" content="p">
<meta property="article:published_time" content="2021-01-24T11:24:01+08:00">
<meta property="article:modified_time" content="2021-09-12T18:05:24+08:00">
<meta itemprop=name content="网络子系统初始化">
<meta itemprop=description content="网络设备初始化
内核初始化代码(init/main.c &ndash;> asmlinkage __visible void __init start_kernel(void))

ps：这里只介绍网络子系统的初始化流程。

系统启动时会执行start_kernel对内核的各个子系统进行初始化。start_kernel会进行必要的初始化任务，比如init_IRQ和softirq_init进行硬中断和软中断初始化,在rest_init中会调用内核线程函数创建一个线程执行kernel_init继续进行其它初始化，start_kernel函数将会继续执行下去并退出。在kernel_init函数中的执行关系kernel_init_freeable()&ndash;>do_basic_setup()&ndash;>do_initcalls()，在do_initcalls函数中，会对调用各个子系统的初始化函数，类似subsys_initcall(net_dev_init)函数。其中net_dev_initnet/core/dev.c为网络设备的初始化函数
内核子系统和编译到内核的驱动都是通过do_initcalls进行初始化的"><meta itemprop=datePublished content="2021-01-24T11:24:01+08:00">
<meta itemprop=dateModified content="2021-09-12T18:05:24+08:00">
<meta itemprop=wordCount content="1478">
<meta itemprop=keywords content="linux,driver,">
<style type=text/css>.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto;padding:45px}@media(max-width:767px){.markdown-body{padding:15px}}</style>
<script>function setTheme({el:a=document.documentElement,mode:b='auto',light:c='light',dark:d='dark'}){a.dataset.colorMode=b,a.dataset.lightTheme=c,a.dataset.darkTheme=d}let prefersDarkMode=window.matchMedia('(prefers-color-scheme: dark)').matches;prefersDarkMode&&setTheme({mode:'dark'})</script>
<link rel=stylesheet href=/style.css type=text/css><body id=content class=markdown-body>
<body>
<div id=post class=post>
<article>
<header>
<h1 class=post-title>网络子系统初始化</h1>
<p>
<small>
2021-01-24, updated 2021-09-12
</small>
</p>
</header>
<aside>
<nav id=TableOfContents></nav>
</aside>
<h1 id=网络设备初始化>网络设备初始化</h1>
<p>内核初始化代码(init/main.c &ndash;> asmlinkage __visible void __init start_kernel(void))</p>
<blockquote>
<p>ps：这里只介绍网络子系统的初始化流程。</p>
</blockquote>
<p>系统启动时会执行start_kernel对内核的各个子系统进行初始化。start_kernel会进行必要的初始化任务，比如init_IRQ和softirq_init进行硬中断和软中断初始化,在rest_init中会调用内核线程函数创建一个线程执行kernel_init继续进行其它初始化，start_kernel函数将会继续执行下去并退出。在kernel_init函数中的执行关系kernel_init_freeable()&ndash;>do_basic_setup()&ndash;>do_initcalls()，在do_initcalls函数中，会对调用各个子系统的初始化函数，类似subsys_initcall(net_dev_init)函数。其中net_dev_init<code>net/core/dev.c</code>为网络设备的初始化函数</p>
<p>内核子系统和编译到内核的驱动都是通过do_initcalls进行初始化的</p>
<p>以下为相关的部分代码
linux-4.4.0</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>start_kernel</span><span class=p>()</span>
<span class=p>{</span>
    <span class=p>...</span>
    <span class=n>boot_cpu_init</span><span class=p>();</span>
    <span class=n>page_address_init</span><span class=p>();</span>
    <span class=n>pr_notice</span><span class=p>(</span><span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>linux_banner</span><span class=p>);</span>
    <span class=n>setup_arch</span><span class=p>(</span><span class=o>&amp;</span><span class=n>command_line</span><span class=p>);</span>
    <span class=p>...</span>
    <span class=n>early_irq_init</span><span class=p>();</span>
    <span class=c1>// 硬中断初始化
</span><span class=c1></span>    <span class=n>init_IRQ</span><span class=p>();</span>
    <span class=n>tick_init</span><span class=p>();</span>
    <span class=n>rcu_init_nohz</span><span class=p>();</span>
    <span class=n>init_timers</span><span class=p>();</span>
    <span class=n>hrtimers_init</span><span class=p>();</span>
    <span class=c1>// 软中断初始化
</span><span class=c1></span>    <span class=n>softirq_init</span><span class=p>();</span>
    <span class=p>...</span>
    <span class=n>rest_init</span><span class=p>();</span>
    <span class=p>...</span>
<span class=p>}</span>

<span class=k>static</span> <span class=n>noinline</span> <span class=kt>void</span> <span class=n>__ref</span> <span class=n>rest_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
	<span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>tsk</span><span class=p>;</span>
	<span class=kt>int</span> <span class=n>pid</span><span class=p>;</span>

	<span class=n>rcu_scheduler_starting</span><span class=p>();</span>
	<span class=cm>/*
</span><span class=cm>	 * We need to spawn init first so that it obtains pid 1, however
</span><span class=cm>	 * the init task will end up wanting to create kthreads, which, if
</span><span class=cm>	 * we schedule it before we create kthreadd, will OOPS.
</span><span class=cm>	 */</span>
	<span class=n>pid</span> <span class=o>=</span> <span class=n>kernel_thread</span><span class=p>(</span><span class=n>kernel_init</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>CLONE_FS</span><span class=p>);</span>
	<span class=cm>/*
</span><span class=cm>	 * Pin init on the boot CPU. Task migration is not properly working
</span><span class=cm>	 * until sched_init_smp() has been run. It will set the allowed
</span><span class=cm>	 * CPUs for init to the non isolated CPUs.
</span><span class=cm>	 */</span>
	<span class=n>rcu_read_lock</span><span class=p>();</span>
	<span class=n>tsk</span> <span class=o>=</span> <span class=n>find_task_by_pid_ns</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>init_pid_ns</span><span class=p>);</span>
	<span class=n>set_cpus_allowed_ptr</span><span class=p>(</span><span class=n>tsk</span><span class=p>,</span> <span class=n>cpumask_of</span><span class=p>(</span><span class=n>smp_processor_id</span><span class=p>()));</span>
	<span class=n>rcu_read_unlock</span><span class=p>();</span>

	<span class=n>numa_default_policy</span><span class=p>();</span>
	<span class=n>pid</span> <span class=o>=</span> <span class=n>kernel_thread</span><span class=p>(</span><span class=n>kthreadd</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>CLONE_FS</span> <span class=o>|</span> <span class=n>CLONE_FILES</span><span class=p>);</span>
	<span class=n>rcu_read_lock</span><span class=p>();</span>
	<span class=n>kthreadd_task</span> <span class=o>=</span> <span class=n>find_task_by_pid_ns</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>init_pid_ns</span><span class=p>);</span>
	<span class=n>rcu_read_unlock</span><span class=p>();</span>

	<span class=cm>/*
</span><span class=cm>	 * Enable might_sleep() and smp_processor_id() checks.
</span><span class=cm>	 * They cannot be enabled earlier because with CONFIG_PREEMPT=y
</span><span class=cm>	 * kernel_thread() would trigger might_sleep() splats. With
</span><span class=cm>	 * CONFIG_PREEMPT_VOLUNTARY=y the init task might have scheduled
</span><span class=cm>	 * already, but it&#39;s stuck on the kthreadd_done completion.
</span><span class=cm>	 */</span>
	<span class=n>system_state</span> <span class=o>=</span> <span class=n>SYSTEM_SCHEDULING</span><span class=p>;</span>

	<span class=n>complete</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kthreadd_done</span><span class=p>);</span>

	<span class=cm>/*
</span><span class=cm>	 * The boot idle thread must execute schedule()
</span><span class=cm>	 * at least once to get things moving:
</span><span class=cm>	 */</span>
	<span class=n>schedule_preempt_disabled</span><span class=p>();</span>
	<span class=cm>/* Call into cpu_idle with preempt disabled */</span>
	<span class=n>cpu_startup_entry</span><span class=p>(</span><span class=n>CPUHP_ONLINE</span><span class=p>);</span>
<span class=p>}</span>

<span class=k>static</span> <span class=kt>int</span> <span class=n>__ref</span> <span class=n>kernel_init</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>unused</span><span class=p>)</span>
<span class=p>{</span>
	<span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>

	<span class=n>kernel_init_freeable</span><span class=p>();</span>
	<span class=cm>/* need to finish all async __init code before freeing the memory */</span>
	<span class=n>async_synchronize_full</span><span class=p>();</span>
	<span class=n>ftrace_free_init_mem</span><span class=p>();</span>
	<span class=n>jump_label_invalidate_initmem</span><span class=p>();</span>
	<span class=n>free_initmem</span><span class=p>();</span>
	<span class=n>mark_readonly</span><span class=p>();</span>

	<span class=cm>/*
</span><span class=cm>	 * Kernel mappings are now finalized - update the userspace page-table
</span><span class=cm>	 * to finalize PTI.
</span><span class=cm>	 */</span>
	<span class=n>pti_finalize</span><span class=p>();</span>

	<span class=n>system_state</span> <span class=o>=</span> <span class=n>SYSTEM_RUNNING</span><span class=p>;</span>
	<span class=n>numa_default_policy</span><span class=p>();</span>

	<span class=n>rcu_end_inkernel_boot</span><span class=p>();</span>

	<span class=k>if</span> <span class=p>(</span><span class=n>ramdisk_execute_command</span><span class=p>)</span> <span class=p>{</span>
		<span class=n>ret</span> <span class=o>=</span> <span class=n>run_init_process</span><span class=p>(</span><span class=n>ramdisk_execute_command</span><span class=p>);</span>
		<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ret</span><span class=p>)</span>
			<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
		<span class=n>pr_err</span><span class=p>(</span><span class=s>&#34;Failed to execute %s (error %d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
		       <span class=n>ramdisk_execute_command</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
	<span class=p>}</span>

	<span class=cm>/*
</span><span class=cm>	 * We try each of these until one succeeds.
</span><span class=cm>	 *
</span><span class=cm>	 * The Bourne shell can be used instead of init if we are
</span><span class=cm>	 * trying to recover a really broken machine.
</span><span class=cm>	 */</span>
	<span class=k>if</span> <span class=p>(</span><span class=n>execute_command</span><span class=p>)</span> <span class=p>{</span>
		<span class=n>ret</span> <span class=o>=</span> <span class=n>run_init_process</span><span class=p>(</span><span class=n>execute_command</span><span class=p>);</span>
		<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ret</span><span class=p>)</span>
			<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
		<span class=n>panic</span><span class=p>(</span><span class=s>&#34;Requested init %s failed (error %d).&#34;</span><span class=p>,</span>
		      <span class=n>execute_command</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>try_to_run_init_process</span><span class=p>(</span><span class=s>&#34;/sbin/init&#34;</span><span class=p>)</span> <span class=o>||</span>
	    <span class=o>!</span><span class=n>try_to_run_init_process</span><span class=p>(</span><span class=s>&#34;/etc/init&#34;</span><span class=p>)</span> <span class=o>||</span>
	    <span class=o>!</span><span class=n>try_to_run_init_process</span><span class=p>(</span><span class=s>&#34;/bin/init&#34;</span><span class=p>)</span> <span class=o>||</span>
	    <span class=o>!</span><span class=n>try_to_run_init_process</span><span class=p>(</span><span class=s>&#34;/bin/sh&#34;</span><span class=p>))</span>
		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

	<span class=n>panic</span><span class=p>(</span><span class=s>&#34;No working init found.  Try passing init= option to kernel. &#34;</span>
	      <span class=s>&#34;See Linux Documentation/admin-guide/init.rst for guidance.&#34;</span><span class=p>);</span>
<span class=p>}</span>


<span class=k>static</span> <span class=n>noinline</span> <span class=kt>void</span> <span class=n>__init</span> <span class=n>kernel_init_freeable</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
	<span class=cm>/*
</span><span class=cm>	 * Wait until kthreadd is all set-up.
</span><span class=cm>	 */</span>
	<span class=n>wait_for_completion</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kthreadd_done</span><span class=p>);</span>

	<span class=cm>/* Now the scheduler is fully set up and can do blocking allocations */</span>
	<span class=n>gfp_allowed_mask</span> <span class=o>=</span> <span class=n>__GFP_BITS_MASK</span><span class=p>;</span>

	<span class=cm>/*
</span><span class=cm>	 * init can allocate pages on any node
</span><span class=cm>	 */</span>
	<span class=n>set_mems_allowed</span><span class=p>(</span><span class=n>node_states</span><span class=p>[</span><span class=n>N_MEMORY</span><span class=p>]);</span>

	<span class=n>cad_pid</span> <span class=o>=</span> <span class=n>task_pid</span><span class=p>(</span><span class=n>current</span><span class=p>);</span>

	<span class=n>smp_prepare_cpus</span><span class=p>(</span><span class=n>setup_max_cpus</span><span class=p>);</span>

	<span class=n>workqueue_init</span><span class=p>();</span>

	<span class=n>init_mm_internals</span><span class=p>();</span>

	<span class=n>do_pre_smp_initcalls</span><span class=p>();</span>
	<span class=n>lockup_detector_init</span><span class=p>();</span>

	<span class=n>smp_init</span><span class=p>();</span>
	<span class=n>sched_init_smp</span><span class=p>();</span>

	<span class=n>page_alloc_init_late</span><span class=p>();</span>
	<span class=cm>/* Initialize page ext after all struct pages are initialized. */</span>
	<span class=n>page_ext_init</span><span class=p>();</span>

	<span class=n>do_basic_setup</span><span class=p>();</span>

	<span class=cm>/* Open the /dev/console on the rootfs, this should never fail */</span>
	<span class=k>if</span> <span class=p>(</span><span class=n>ksys_open</span><span class=p>((</span><span class=k>const</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span> <span class=s>&#34;/dev/console&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
		<span class=n>pr_err</span><span class=p>(</span><span class=s>&#34;Warning: unable to open an initial console.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>

	<span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=n>ksys_dup</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
	<span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=n>ksys_dup</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
	<span class=cm>/*
</span><span class=cm>	 * check if there is an early userspace init.  If yes, let it do all
</span><span class=cm>	 * the work
</span><span class=cm>	 */</span>

	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ramdisk_execute_command</span><span class=p>)</span>
		<span class=n>ramdisk_execute_command</span> <span class=o>=</span> <span class=s>&#34;/init&#34;</span><span class=p>;</span>

	<span class=k>if</span> <span class=p>(</span><span class=n>ksys_access</span><span class=p>((</span><span class=k>const</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span>
			<span class=n>ramdisk_execute_command</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
		<span class=n>ramdisk_execute_command</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
		<span class=n>prepare_namespace</span><span class=p>();</span>
	<span class=p>}</span>

	<span class=cm>/*
</span><span class=cm>	 * Ok, we have completed the initial bootup, and
</span><span class=cm>	 * we&#39;re essentially up and running. Get rid of the
</span><span class=cm>	 * initmem segments and start the user-mode stuff..
</span><span class=cm>	 *
</span><span class=cm>	 * rootfs is available now, try loading the public keys
</span><span class=cm>	 * and default modules
</span><span class=cm>	 */</span>

	<span class=n>integrity_load_keys</span><span class=p>();</span>
	<span class=n>load_default_modules</span><span class=p>();</span>
<span class=p>}</span>


<span class=cm>/*
</span><span class=cm> * Ok, the machine is now initialized. None of the devices
</span><span class=cm> * have been touched yet, but the CPU subsystem is up and
</span><span class=cm> * running, and memory and process management works.
</span><span class=cm> *
</span><span class=cm> * Now we can finally start doing some real work..
</span><span class=cm> */</span>
<span class=k>static</span> <span class=kt>void</span> <span class=n>__init</span> <span class=n>do_basic_setup</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
	<span class=n>cpuset_init_smp</span><span class=p>();</span>
	<span class=n>shmem_init</span><span class=p>();</span>
	<span class=n>driver_init</span><span class=p>();</span>
	<span class=n>init_irq_proc</span><span class=p>();</span>
	<span class=n>do_ctors</span><span class=p>();</span>
	<span class=n>usermodehelper_enable</span><span class=p>();</span>
	<span class=n>do_initcalls</span><span class=p>();</span>
<span class=p>}</span>

<span class=k>static</span> <span class=kt>void</span> <span class=n>__init</span> <span class=n>do_initcalls</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
	<span class=kt>int</span> <span class=n>level</span><span class=p>;</span>

	<span class=k>for</span> <span class=p>(</span><span class=n>level</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>level</span> <span class=o>&lt;</span> <span class=n>ARRAY_SIZE</span><span class=p>(</span><span class=n>initcall_levels</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>level</span><span class=o>++</span><span class=p>)</span>
		<span class=n>do_initcall_level</span><span class=p>(</span><span class=n>level</span><span class=p>);</span>
<span class=p>}</span>

<span class=n>subsys_initcall</span><span class=p>(</span><span class=n>net_dev_init</span><span class=p>);</span>
<span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=nf>net_dev_init</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>

</code></pre></div><h1 id=net_dev_init>net_dev_init</h1>
<p>部分代码注释
linux-4.4.0</p>
<p>位置：<code>net/core/dev.c</code></p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cm>/*
</span><span class=cm> *  Initialize the DEV module. At boot time this walks the device list and
</span><span class=cm> *  unhooks any devices that fail to initialise (normally hardware not
</span><span class=cm> *  present) and leaves us with a valid list of present and active devices.
</span><span class=cm> *
</span><span class=cm> */</span>

<span class=cm>/*
</span><span class=cm> *       This is called single threaded during boot, so no need
</span><span class=cm> *       to take the rtnl semaphore.
</span><span class=cm> */</span>
<span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=nf>net_dev_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>rc</span> <span class=o>=</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>

    <span class=n>BUG_ON</span><span class=p>(</span><span class=o>!</span><span class=n>dev_boot_phase</span><span class=p>);</span>

	<span class=cm>/* 初始化proc配置，创建部分文件
</span><span class=cm>	* /proc/net/dev 
</span><span class=cm>	* /proc/net/softnet_stat 
</span><span class=cm>	* /proc/net/ptype 
</span><span class=cm>	* /proc/net/dev_mcast
</span><span class=cm>	*/</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>dev_proc_init</span><span class=p>())</span>
        <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>

	<span class=c1>// 初始化namespace相关
</span><span class=c1></span>
    <span class=k>if</span> <span class=p>(</span><span class=n>netdev_kobject_init</span><span class=p>())</span>
        <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>

    <span class=n>INIT_LIST_HEAD</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ptype_all</span><span class=p>);</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>PTYPE_HASH_SIZE</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
        <span class=n>INIT_LIST_HEAD</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ptype_base</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>

    <span class=n>INIT_LIST_HEAD</span><span class=p>(</span><span class=o>&amp;</span><span class=n>offload_base</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>register_pernet_subsys</span><span class=p>(</span><span class=o>&amp;</span><span class=n>netdev_net_ops</span><span class=p>))</span>
        <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
        
    <span class=cm>/*  
</span><span class=cm>     *  Initialise the packet receive queues.
</span><span class=cm>     */</span>

    <span class=n>for_each_possible_cpu</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>struct</span> <span class=n>softnet_data</span> <span class=o>*</span><span class=n>sd</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>per_cpu</span><span class=p>(</span><span class=n>softnet_data</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
        
        <span class=n>skb_queue_head_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sd</span><span class=o>-&gt;</span><span class=n>input_pkt_queue</span><span class=p>);</span>
        <span class=n>skb_queue_head_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sd</span><span class=o>-&gt;</span><span class=n>process_queue</span><span class=p>);</span>
        <span class=n>INIT_LIST_HEAD</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sd</span><span class=o>-&gt;</span><span class=n>poll_list</span><span class=p>);</span>
        <span class=n>sd</span><span class=o>-&gt;</span><span class=n>output_queue_tailp</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>sd</span><span class=o>-&gt;</span><span class=n>output_queue</span><span class=p>;</span>
<span class=cp>#ifdef CONFIG_RPS
</span><span class=cp></span>        <span class=n>sd</span><span class=o>-&gt;</span><span class=n>csd</span><span class=p>.</span><span class=n>func</span> <span class=o>=</span> <span class=n>rps_trigger_softirq</span><span class=p>;</span>
        <span class=n>sd</span><span class=o>-&gt;</span><span class=n>csd</span><span class=p>.</span><span class=n>info</span> <span class=o>=</span> <span class=n>sd</span><span class=p>;</span>
        <span class=n>sd</span><span class=o>-&gt;</span><span class=n>cpu</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span> 
<span class=cp>#endif  
</span><span class=cp></span>
        <span class=n>sd</span><span class=o>-&gt;</span><span class=n>backlog</span><span class=p>.</span><span class=n>poll</span> <span class=o>=</span> <span class=n>process_backlog</span><span class=p>;</span>
        <span class=n>sd</span><span class=o>-&gt;</span><span class=n>backlog</span><span class=p>.</span><span class=n>weight</span> <span class=o>=</span> <span class=n>weight_p</span><span class=p>;</span>
    <span class=p>}</span>   
    
    <span class=n>dev_boot_phase</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    
    <span class=cm>/* The loopback device is special if any other network devices
</span><span class=cm>     * is present in a network namespace the loopback device must
</span><span class=cm>     * be present. Since we now dynamically allocate and free the
</span><span class=cm>     * loopback device ensure this invariant is maintained by
</span><span class=cm>     * keeping the loopback device as the first device on the
</span><span class=cm>     * list of network devices.  Ensuring the loopback devices
</span><span class=cm>     * is the first device that appears and the last network device
</span><span class=cm>     * that disappears.
</span><span class=cm>     */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>register_pernet_device</span><span class=p>(</span><span class=o>&amp;</span><span class=n>loopback_net_ops</span><span class=p>))</span>
        <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
        
    <span class=k>if</span> <span class=p>(</span><span class=n>register_pernet_device</span><span class=p>(</span><span class=o>&amp;</span><span class=n>default_device_ops</span><span class=p>))</span>
        <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
        
    <span class=n>open_softirq</span><span class=p>(</span><span class=n>NET_TX_SOFTIRQ</span><span class=p>,</span> <span class=n>net_tx_action</span><span class=p>);</span>
    <span class=n>open_softirq</span><span class=p>(</span><span class=n>NET_RX_SOFTIRQ</span><span class=p>,</span> <span class=n>net_rx_action</span><span class=p>);</span>
    
	<span class=c1>// 注册于cpu热插拔事件相关的通知链，处理cpu停止事件。
</span><span class=c1></span>	<span class=c1>// 接收到消息时，CPU入口队列里的缓冲区出列，然后传给netif_rx。
</span><span class=c1></span>		
    <span class=n>hotcpu_notifier</span><span class=p>(</span><span class=n>dev_cpu_callback</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
    <span class=n>dst_subsys_init</span><span class=p>();</span>
    <span class=n>rc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=nl>out</span><span class=p>:</span>
    <span class=k>return</span> <span class=n>rc</span><span class=p>;</span>
<span class=p>}</span>   
</code></pre></div>
</article>
</div>
</body>
<div>
<small> words: 1478 tags:</small>
<small><code><a href=https://arair.net/tags/linux>linux</a></code></small>
<small><code><a href=https://arair.net/tags/driver>driver</a></code></small>
</div>
</html>
</body>
<script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?bd28dafb59c7621d0ab721cefd01691b",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script>
<script id=LA_COLLECT src=//sdk.51.la/js-sdk-pro.min.js></script>
<script>LA.init({id:"JMTlKgP6j8mqnJSa",ck:"JMTlKgP6j8mqnJSa"})</script>
<link rel=stylesheet href=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.2.0/build/styles/default.min.css>
<script src=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.2.0/build/highlight.min.js></script>
<script>hljs.highlightAll()</script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>window.onload=function(){mermaid.initialize({theme:"default"}),mermaid.init(void 0,".language-mermaid")}</script></html>